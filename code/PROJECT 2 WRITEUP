 Title:  Writeup for Project 2, Fall 2015
 Date:  10/18/15
 Group:	Erika Johnson	erikajoh@usc.edu	
		Heather Persson	hpersson@usc.edu	
		Lorraine Sposto	llsposto@usc.edu

I. Requirements:
- Expand the exception handler to handle new types of interrupts for new syscalls
- Implement the following new system calls: Fork, Exec, Exit, Yield
- Implement system calls for Locks (Acquire, Release) and Conditions (Wait, Signal, and Broadcast) that essentially wrap our implementation from Part 1.
- Implement any other system calls required for use and testing, such as CreateLock, CreateCondition, DestroyLock, DestroyCondiiton and system calls required to upgrade our PassportOffice (such as a Print syscall)
- Bulletproof the kernal from errors sent by user program calls.
- Upgrade the method of memory allocation to a mapped relationship of physical to virtual to allow for multiple programs to run at once.
- Provide way to copy data between the kernel and the user 
- Support multi-threaded multi-programs
- Update the passport office from a part of the Nachos kernal code to a userprogram that can run multiple instances of itself
- Develop tests for all functionality added

II. Assumptions:
	- A thread will explicitly exit out of itself
	- Nachos has finished running when the last running process finishes.

III. Design:
- System calls are handled through the exception handler. The exception handler receives an exception and checks for the corresponding value before executing the correcting system call.
- For the Fork system call, we must create a new thread, then resize the running process's page table to make room for 8 more pages for the new thread. After doing so, we update the appropriate values for the process (location of new thread stack, number of running threads, etc) and call the OS fork.
- For the Exec system call, we must read in the process that is setting up to execute. We must then create a new address space and process, update the process table accordingly, then create a first thread for the process and fork it from the currently executing thread.
- For the Exit system call, we must consider 3 cases. If the thread is not the last thread in the process, it simply frees up its own stack before finishing. If the thread is the last thread in a process, it must clean up the entire process's page table before finishing itself. If the thread is the last thread in the last process, it must halt all of Nachos.
- For the Yeild system call, the machine simply yields.
- For the Lock and Condition system calls, the system call itself simply checks for invalid values of the Lock/Condition before passing the handling off to our implemntation of Locks and Conditions from Project 1.
- Page Table must keep track of the relationship between virtual and physical pages, and is unique to every process that is created
- The Process Table keeps track of all processes. Processes are indexed on creation so that they may be kept track of in the process table.
- A process contains and address space, an array to keep track of thread stacks, the and number of currently active threads.
- A thread contains an index that indicates it is the nth thread created in the process. In this way, the location of the first page of their stack can be referenced in the process struct.
- A thread interfaces with the process table by looking at the index of its address space, which is the same for all threads in a process. The process interfaces with threads by using their index to access their thread stack. 

IV. Implementation:
	+ Files Modified
		addrspace.cc - updated constructor to correclty map virtual memory to a physical page, changing variable scope (or using getters/setters) to be able to be accessed by threads
		exception.cc - implementation of all new system calls
		progtest.cc - updating the process table with the very first process
		start.s - added assembly for new system calls
		syscall.h - added new #define values for new system calls, created function prototypes
		system.h - new global variables delcarations
		system.cc - new global varaible initialization
		thread.h/cc - addition of counter

	+ Files added
		helloworld.c - short program to test exec functionality
		testcondition.c - testing condition functionality
		testfork.c - testing fork functionality
		testlock.c - testing lock functionality	

	+ Data Structures added, and the file they were added to.
		system.h/cc - 
			struct kernelCondition {
				Condition * condition;
				AddrSpace * addrsp;
				bool isToBeDeleted;
			};

			struct kernelLock {
				Lock * lock;
				AddrSpace * addrsp;
				bool isToBeDeleted;
			};

			struct process {
				int * threadStacks;
				int numThreadsRunning; 
				int numThreadsTotal;
			};

			kernelCondition kernelConditionList[]
			kernelLock kernelLockList[] 
			BitMap bitmap
			Lock bitmapLock
			process processTable[]
			Lock processLock

	+ Data Structures modified, and the file they were added to.
			
		addrspace.h:
			AddrSpace - addition of int for processIndex and numPages
		thread.h 
			Thread - addition of int for threadIndex

	+ Functions added and in which file.
			syscall.h (prototypes):
				Yield() - interface for userprogram to call Yield 
				Acquire(int index) - interface for userprogram to call Acquire
				Release(int index) - interface for userprogram to call Releae
				Wait(int conditionIndex, int lockIndex) - interface for userprogram to call Wait
				Signal(int conditionIndex, int lockIndex) - interface for userprogram to call Signal
				Broadcast(int conditionIndex, int lockIndex) - interface for userprogram to call Broadcast
				CreateLock(char* name, int len) - interface for userprogram to create a Lock to use
				DestroyLock(int index) - interface for userprogram to destroy a Lock no longer in use
				CreateCondition(char* name, int len) -  interface for userprogram to create a Condition to use
				DestroyCondition(int index) - interface for userprogram to destroy a Lock no longer in use

			exception.h/cc
				Exit_Syscall(int status) - terminates the execution of the currently running thread
				Exec_Syscall(int vaddr, int len) - begins a new process
				exec_thread(int vaddr) - helper funciton to kick off new process
				kernel_thread(int vaddr) - helper function to kick off new thread
				Fork_Syscall(int vaddr) - creates a new thread within a process
				Yield_Syscall(int vaddr) - relinquishes control of the CPU
				Acquire_Syscall(int index) - acquires the lock with the given index
				Release_Syscall(int index) - releases lock with the given index
				Wait_Syscall(int conditionIndex, int lockIndex) - has the condition at the given index wait to be signaled
				Signal_Syscall(int conditionIndex, int lockIndex) - signals the first waiting thread on the condition at the given index
				Broadcast_Syscall(int conditionIndex, int lockIndex) - signals all waiting threads on the condition at the given index
				CreateLock_Syscall(int vaddr, int len) - creates a lock with given name
				DestroyLock_Syscall(int index) - destroys lock contained at index
				CreateCondition_Syscall(int vaddr, int len) - creates a condition with given name
				DestroyCondition_Syscall(int index) - destroys condition contained at index

	+ Functions modified and in which file.
			addrspace.cc:
				AddrSpace(OpenFile *executable) - change from supporting uniprogram to multiprogram by splitting out physical/virtual to a non-direct mapping
			exception.cc:
				ExceptionHandler(ExceptionType which) - expand for new syscall cases
			progtest.cc:
				StartProcess(char *filename) - add very first process to the process table

V. Testing:  (For each test case, you must show)
	+ How to test
- How to run the test cases, the commands, the arguments and so on.
	+ Test Output
- Describe the testing output. You don't have to dump all the output info. Just make sure your description can exactly reflect your output. The grader of your submission will be wanting to compare the output they get with what you say the output is.

+ Part 2 Tests
+ helloworld: 
	- helper user program that prints "Hello World".
+ matmult2: 
	- helper user program that is a copy of matmult, but prints the output to console.
+ testexec: 
	- executes the helloworld user program 5 times. 
	- The output is the string "Hello world" printed 5 times, which proves that the user program executed successfully all five times.
+ testfork:
	- forks a helloworld function 5 times. 
	- The output is the string "Hello world" printed 5 times. This proves that each thread launched by fork successfully executed the function and finished.
+ testforkexec1:
	- executes helloworld 2 times, matmult2 2 times, and forks a helloworld function 2 times
	- output is "Hello world" 4 times and the results of matmult twice.
	- if the output is satisfied, it proves each forked function and executed process successfully completed.
+ testforkexec2:
	- executes matmult2, forks a hello world function, executes the testfork user program, then executes the helloworld user program.
	- output is the result of matmult2 once, and "Hello world" 7 times total.
	- this test demonstrates forking from within a user program executed by the Exec syscall.
	- the output proves all forked functions and executed processes are successful, no matter whether the syscalls are called by the main process or thread.
+ testforkexecbad:
	- attempts to call Exec syscall on a couple of nonexistent executables.
	- prints an error indicating the files don't exist, and continues to complete the subsequent instructions.
	- proves the Nachos will not blow up due to input errors and will continue to execute the remaining syscalls without a hitch.

VI. Discussion:
	+ Experiment expectation.  (What is supposed to happen.)
	+ Experiment result.  (What actually happened.)
	+ Explanation
		- Explain your experiment result - how it proves what 
		  you were supposed to prove.

VIII. Miscellaneous:
- Whatever else you want the grader know about your development.  You can create your own subsections headings here.