 Title:  Writeup for Project 4, Fall 2015
 Date:  11/29/15
 Group:	Erika Johnson	erikajoh@usc.edu	
		Heather Persson	hpersson@usc.edu	
		Lorraine Sposto	llsposto@usc.edu

I. Requirements:
- Convert passport office (PPO) into a distributable program
	- Each PPO entity is a user program to be executed
	- PPO entities are clients and shared data through monitor variables on servers
	- PPO entities occupy different mailbox slots on the same or different machines, communicate entirely through server
- Expand RPCs to coordinate shared data distributed amongst multiple servers, in which case all servers do not have each shared resource and must communicate with the other servers


II. Assumptions:
	- Fewer than 10 of each clerk/cashier type running at one time

III. Design:
+ Part 1
	- Each PPO entity is contained within its own user program, prefixed with 'ppo_': ppo_appclerk, ppo_cashier, ppo_customer, ppo_manager, ppo_picclerk, ppo_ppclerk
	- User program run_passport_office executes each PPO participant
	- PPO entities index themselves through monitor variables
	- PPO entities communicate exclusively through the server
	- PPO entities use system calls to interface with the OS, and through the OS the server.

+ Part 2
	- Server Design
		- in main.cc
		- Each server awaits received messages into its mailbox #0, and each client sends mail to a servers mailbox #0. Even though message handling is multi-threaded, messages are always received in MB #0.
		- Upon receiving a message, a server parses the message for each value in the message (typically: MSG_TYPE ARG1 ARG2 ...) and passes the arguments to the appropriate handling routine (be it a syscall handler or server message processing)
		- Each syscall handling routine contains boolean parameters to indicate whether message to either the sender or originating client should be sent
	- Client Design
		- Each process/thread running on the client machine receives messages in the mailbox indicated by that thread's index in order to distinguish appropriate ownerships, message recipients, etc.
		- If a client receives an error message back from the server for a syscall, ... ???


IV. Implementation:
	+ Files Modified
		- threads/main.cc - server functionality
		- threads/sync.h;.cc - modified monitor variables
		- userprog/exception.cc - client functionality
		- userprog/progtest.cc - added process index to main thread via monitor variable
		- test/run_passport_office.c - changed to execute PPO entities

	+ Files added
		test/ppo_appclerk.c - application clerk user program
		test/ppo_cashier.c - cashier user program
		test/ppo_manager.c - manager user program
		test/ppo_picclerk.c - picture clerk user program
		test/ppo_ppclerk.c - passport clerk user program

	+ Data Structures added, and the file they were added to.
		- threads/system.h;.cc
			struct kernelMonitor {
				int num;
				Monitor * monitor;
				AddrSpace * addrsp;
				bool isToBeDeleted;
			};
			extern kernelMonitor kernelMonitorList[];
			extern int kernelMonitorIndex;
			extern const int NUM_KERNEL_MONITORS;
			extern Lock kernelMonitorLock;

			struct Request {
				enum Status {
					PENDING, FAILED, SUCCESS
				};
				Status status;
				// one slot response for each  machine by index of machine
				int noResponses; // = new int[NUM_SERVERS]
				char * msg;
				int requesterMachineID;
				int requesterMBID;
				int requestType;
				int index;
				void* primaryIndex;
				void* secondaryIndex;
			};
			const int CREATELOCK = 1;
			const int DESTROYLOCK = 2;
			const int ACQUIRELOCK = 3;
			const int RELEASELOCK = 4;
			const int CREATECOND = 5;
			const int DESTROYCOND = 6;
			const int WAITCOND = 7;
			const int SIGNALCOND = 8;
			const int BROADCASTCOND = 9;
			const int CREATEMV = 10;
			const int DESTROYMV = 11;
			const int GETMV = 12;
			const int SETMV = 13;
			const int CHECKLOCK = 14;
			const int SERVERMSG = 500;
			const int SERVERRESPONSE = 501;
			extern int NUM_SERVERS;
			extern Lock requestLock;
			extern vector<Request *> requests;

			extern Lock currentMBIDLock;
			extern int currentMBID;

	+ Data Structures modified, and the file they were added to.
		- threads/sync.h;.cc
			class Monitor {
			    public:
			        Monitor(char* debugName, int maxSize);
			        ~Monitor();
			        char* getName() { return (name); }
			        int getVal(int position);
			        void setVal(int position, int value);

			    private:
			        char* name;
				    int* val;
			        int size;
			};	
		
		

	+ Functions added and in which file.
		- threads/main.cc
			- void askOtherServersFcn(Request*, int, void*, void*) - function for server to construct request messages to other servers
			- void awaitResponse(int) - function to fork to await responses from other servers, so that it can go on to handle other incoming requests
			- void forkWait(int params) - function for server to fork so that it can move on to handle other incoming messages while waiting on a condition
			- void forkSignal(int params) - function for server to fork so that it can move on to handle other incoming messages while signaling on a condition
			- void forkBroadcast(int params) - function for server to fork so that it can move on to handle other incoming messages while broadcasting on a condition
			- void receiveServerMsg(char * msg, PacketHeader inPktHdr, MailHeader inMailHdr) - function for a server to handle incoming requests (questions) from another server (different from awaitResponse)

	+ Functions modified and in which file.
		- threads/main.cc
			- main() - modified to add new command line flags:
				- "-servers <#>" - flag to set the number of servers
				- "-server" - flag to run a server
			- beServer() - modified to handle incoming server messages and other management of message-sending coordination
			- CreateLock() - this and the following were modified to query other servers for missing resources before sending a failure message
			- DestroyLock()
			- AcquireLock()
			- ReleaseLock()
			- CreateCondition()
			- DestroyCondition()
			- WaitCondition()
			- SignalCondition()
			- BroadcastCondition()
			- CreateMonitor()
			- DestroyMonitor()
			- GetMonitor()
			- SetMonitor()
		- userprog/progtest.cc
			- void StartProcess(char *filename) - modified to set thread index based on mailbox # monitor variable
		- userprog/exception.cc
			- void Fork_Syscall(int vaddr, int len) - modified to set thread index based on mailbox # monitor variable
			- void Exec_Syscall(int vaddr, int len) - modified to set thread index based on mailbox # monitor variable
			- void Acquire_Syscall(int index) - this and the following syscall functions were modified to randomly choose a server to message to complete the action
			- void Release_Syscall(int index)
			- void Wait_Syscall(int conditionIndex, int lockIndex)
			- void Signal_Syscall(int conditionIndex, int lockIndex)
			- void Broadcast_Syscall(int conditionIndex, int lockIndex)
			- int CreateLock_Syscall(int vaddr, int len)
			- void DestroyLock_Syscall(int index)
			- int CreateCondition_Syscall(int vaddr, int len)
			- void DestroyCondition_Syscall(int index)
			- int CreateMonitor_Syscall(int vaddr, int len, int size)
			- void DestroyMonitor_Syscall(int monitorIndex)
			- int GetMonitor_Syscall(int monitorIndex, int position)
			- int SetMonitor_Syscall(int monitorIndex, int position, int value)

V. Testing:  
+ To run a server:
	nachos -m <#MACHINE_NUM> -servers <#NUM_SERVERS> -server
+ To run a client user program:
	nachos -m <#MACHINE_NUM> -servers <#NUM_SERVERS> -x <USER_PROG>
+ Part 1:
	- ???
+ Part 2: 
	- ???

VI. Discussion:
+ Part 1-2
	+ Experiment expectation.  (What is supposed to happen.)
		
	+ Experiment result.  (What actually happened.)
		
	+ Explanation
+ Part 2
	+ Experiment expectation
		
	+ Experiment Result
		
	+ Explanation
		



VIII. Miscellaneous:
