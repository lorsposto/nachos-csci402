 Title:  Writeup for Project 3, Fall 2015
 Date:  11/07/15
 Group:	Erika Johnson	erikajoh@usc.edu	
		Heather Persson	hpersson@usc.edu	
		Lorraine Sposto	llsposto@usc.edu

I. Requirements:
- Modify Nachos' memory mechanism to allow for virtual memory
- Implement an inverse page table
- Implement Demand Paged Virtual Memory, preloading nothing into memory
- Implement the MMU process to handle page faults, IPT misses, and employ the TLB
- Implement caching through a TLB to provide fast access to already-translated virtual pages
- Implement caching through a swap file, to store in such a way that gives the illusion of infinite memory and avoid loading from disk
- Implement Random and FIFO page replacement for when physical memory is full
- Provide necessary tests to demonstrate the functionality of the IPT, TLB, eviction and swap file
 //-- RPC ---//

II. Assumptions: *** TODO
	- A thread will explicitly exit out of itself
	- Nachos has finished running when the last running process finishes.

III. Design:
+ Parts 1 & 2
	- On a page fault, handlePageFault() begins the routine to load a page into memory.
	- handlePageFault():
		- searches IPT for physical page number that corresponds to the requested virtual page
		- if the PPN is not found --> ppn = handleIPTMiss()
		- with a valid PPN, updates the TLB with the page
		- if the eviction policy is FIFO, the VPN is added to the queue
	- handleIPTMiss()
		- finds an empty PPN in memory to put the VP
		- if no empty PPN --> ppn = handleMemoryFull()
		- assesses the location of the needed VP from the processes page table
		- if in EXECUTABLE, read a page from certain offset of the executable to memory
		- if in SWAP, read from a certain offset of the swap file to memory
		- updates physical page for the page table entry of the VPN
		- updates the IPT entry for the PPN found
		- returns PPN
	- handleMemoryFull()
		- selects a PPN to evict depending on policy: either random or FIFO
		- for FIFO: a pageQueue holds the recently accessed VPNs
		- after a page is selected for eviction, if it is in the TLB the TLB entry is invalidated
		- if the page is dirty, it is written to the swap file
		- returns PPN

	*** TODO RPC

IV. Implementation:
	+ Files Modified
		addrspace.cc - updated constructor to load nothing into memory, added PageTableEntry class
		exception.cc - implementation of all new system calls; implementation of virtual memory management routines
		progtest.cc - updating the process table with the very first process
		start.s - added assembly for new system calls
		syscall.h - added new #define values for new system calls, created function prototypes
		system.h - new global variables delcarations
		system.cc - new global varaible initialization
		test/Makefile - to include new user programs
		vm/Makefile - include network directory

		*** TODO?

	+ Files added
		swapfile - file to be opened as the swapfile
		test/fork_matmult - test to fork 2 instances of matmult

	+ Data Structures added, and the file they were added to.
		system.h/cc - 
			class PageTableEntry : public TranslationEntry {
			public:
				enum DiskLocation {
					SWAP,
					EXECUTABLE,
					MEMORY
				};
				int byteOffset;
				int swapOffset;
				DiskLocation diskLocation;
			};
			class IPTEntry : public PageTableEntry {
			public:
				AddrSpace * space;
			};
			IPTEntry ipt[];
			Lock iptLock;
			Lock pageTableLock;
			int currentTLBEntry;
			bool isFIFO; //if not FIFO, RAND
			Queue pageQueue;
			OpenFile * swapFile;
			char * swapFileName;
			BitMap swapFileBM;
			Lock swapLock;

	+ Data Structures modified, and the file they were added to.
			
		addrspace.h:
			AddrSpace - page table modified to be of PageTableEntries

	+ Functions added and in which file.
			exception.h/cc
				handlePageFault() -- begins page fault handling routine to find PPN and update TLB
				handleIPTMiss() -- handles an IPT from handlePageFault and returns PPN
				handleMemoryFull() -- handles page eviction and returns PPN for handleIPTMiss
				beServer() -- *** TODO RPC

	+ Functions modified and in which file.
			addrspace.cc:
				AddrSpace(OpenFile *executable) - change to not load anything into memory
				SaveState/RestoreState - invalidates TLB on context switch
			exception.cc:
				ExceptionHandler(ExceptionType which) - expand for new syscall cases, add page fault handling

V. Testing:  
+ NOTE: Make sure a file named 'swapfile' exists in the code directory

	+ Part 1 and Part 2 Tests:
- Part 1 Assumption: NumPhysPages is set large (e.g. 2048, at least 120) so that many instances of matmult fits into physical memory
- Part 2 Assumption: NumPhysPages is set to 32 so that large user programs like matmult do not fit into physical memory

	+ test/fork_matmult
		- forks two instances of matmult, which has been converted into a fork-able function within fork_matmult.c
		- Expected output:
			$: nachos -P RAND -x ../test/fork_matmult
			Exit result: 0
			Exit result: 7220
			Exit result: 7220
			Machine halting!

			Ticks: total 2675684, idle 0, system 1269700, user 1405984
			Disk I/O: reads 0, writes 0
			Console I/O: reads 0, writes 0
			Paging: faults 0
			Network I/O: packets received 0, sent 0

	+ test/exec_matmult:
		- execs two instances of the matmult user program
		- Expected output:
			$: nachos -P RAND -x ../test/exec_matmult
			Exit result: 0
			Exit result: 7220
			Exit result: 7220
			Machine halting!

			Ticks: total 2675403, idle 0, system 1269450, user 1405953
			Disk I/O: reads 0, writes 0
			Console I/O: reads 0, writes 0
			Paging: faults 0
			Network I/O: packets received 0, sent 0

VI. Discussion:
	+ Experiment expectation.  (What is supposed to happen.)
		fork_matmult:
			- Part 1 (NumPhysPages large): matmult should successfully execute two times by being forked as a function. The output each time is printed on exit. 
			- Part 2 (NumPhysPages small): matmult should successfully execute two times by being forked as a function. The output each time is printed on exit. 
		exec_matmult:
			- Part 1 (NumPhysPages large): matmult should successfully execute two times by being forked as a user program. The output each time is printed on exit.
			- Part 2 (NumPhysPages small): matmult should successfully execute two times by being forked as a user program. The output each time is printed on exit.

	+ Experiment result.  (What actually happened.)
		fork_matmult: matmult runs twice successfully and the return value is printed on exit.
		exec_matmult: matmult runs twice successfully and the return value is printed on exit.
		
	+ Explanation
		fork_matmult:
			- Part 1 (NumPhysPages large): Because NumPhysPages is large, memory management only needs to utilize the PTs, IPT, and TLB.
			- Part 2 (NumPhysPages small): Because NumPhysPages is small, VM utilizes PTs, IPT, and TLB, as well as a swapfile and page eviction when memory is full.
		exec_matmult: 
			- Part 1 (NumPhysPages large): Because NumPhysPages is large, memory management only needs to utilize the PTs, IPT, and TLB. Because nothing is preloaded into memory initially, we know our implementation of handling page faults is successful as the program is dynamically loaded into memory.
			- Part 2 (NumPhysPages small): Because NumPhysPages is small, VM utilizes PTs, IPT, and TLB, as well as a swapfile and page eviction when memory is full. Since matmult is larger than the small physical memory size (NumPhysPages == 32), we know that at some point physical memory will run out and page eviction and swap file use will have to take place.


VIII. Miscellaneous:
