 Title:  Writeup for Project 3, Fall 2015
 Date:  11/07/15
 Group:	Erika Johnson	erikajoh@usc.edu	
		Heather Persson	hpersson@usc.edu	
		Lorraine Sposto	llsposto@usc.edu

I. Requirements:
- Modify Nachos' memory mechanism to allow for virtual memory
- Implement an inverse page table
- Implement Demand Paged Virtual Memory, preloading nothing into memory
- Implement the MMU process to handle page faults, IPT misses, and employ the TLB
- Implement caching through a TLB to provide fast access to already-translated virtual pages
- Implement caching through a swap file, to store in such a way that gives the illusion of infinite memory and avoid loading from disk
- Implement Random and FIFO page replacement for when physical memory is full
- Provide necessary tests to demonstrate the functionality of the IPT, TLB, eviction and swap file
 //-- RPC ---//

II. Assumptions: *** TODO
	- A thread will explicitly exit out of itself
	- Nachos has finished running when the last running process finishes.

III. Design:
+ Parts 1 & 2
	- On a page fault, handlePageFault() begins the routine to load a page into memory.
	- handlePageFault():
		- searches IPT for physical page number that corresponds to the requested virtual page
		- if the PPN is not found --> ppn = handleIPTMiss()
		- with a valid PPN, updates the TLB with the page
		- if the eviction policy is FIFO, the VPN is added to the queue
	- handleIPTMiss()
		- finds an empty PPN in memory to put the VP
		- if no empty PPN --> ppn = handleMemoryFull()
		- assesses the location of the needed VP from the processes page table
		- if in EXECUTABLE, read a page from certain offset of the executable to memory
		- if in SWAP, read from a certain offset of the swap file to memory
		- updates physical page for the page table entry of the VPN
		- updates the IPT entry for the PPN found
		- returns PPN
	- handleMemoryFull()
		- selects a PPN to evict depending on policy: either random or FIFO
		- for FIFO: a pageQueue holds the recently accessed VPNs
		- after a page is selected for eviction, if it is in the TLB the TLB entry is invalidated
		- if the page is dirty, it is written to the swap file
		- returns PPN

	*** TODO RPC

IV. Implementation:
	+ Files Modified
		addrspace.cc - updated constructor to load nothing into memory, added PageTableEntry class
		exception.cc - implementation of all new system calls; implementation of virtual memory management routines
		progtest.cc - updating the process table with the very first process
		start.s - added assembly for new system calls
		syscall.h - added new #define values for new system calls, created function prototypes
		system.h - new global variables delcarations
		system.cc - new global varaible initialization
		test/Makefile - to include new user programs
		vm/Makefile - include network directory

		*** TODO?

	+ Files added
		swapfile - file to be opened as the swapfile
		test/fork_matmult - test to fork 2 instances of matmult

	+ Data Structures added, and the file they were added to.
		system.h/cc - 
			class PageTableEntry : public TranslationEntry {
			public:
				enum DiskLocation {
					SWAP,
					EXECUTABLE,
					MEMORY
				};
				int byteOffset;
				int swapOffset;
				DiskLocation diskLocation;
			};
			class IPTEntry : public PageTableEntry {
			public:
				AddrSpace * space;
			};
			IPTEntry ipt[];
			Lock iptLock;
			Lock pageTableLock;
			int currentTLBEntry;
			bool isFIFO; //if not FIFO, RAND
			Queue pageQueue;
			OpenFile * swapFile;
			char * swapFileName;
			BitMap swapFileBM;
			Lock swapLock;

	+ Data Structures modified, and the file they were added to.
			
		addrspace.h:
			AddrSpace - page table modified to be of PageTableEntries

	+ Functions added and in which file.
			exception.h/cc
				handlePageFault() -- begins page fault handling routine to find PPN and update TLB
				handleIPTMiss() -- handles an IPT from handlePageFault and returns PPN
				handleMemoryFull() -- handles page eviction and returns PPN for handleIPTMiss
				beServer() -- *** TODO RPC

	+ Functions modified and in which file.
			addrspace.cc:
				AddrSpace(OpenFile *executable) - change to not load anything into memory
				SaveState/RestoreState - invalidates TLB on context switch
			exception.cc:
				ExceptionHandler(ExceptionType which) - expand for new syscall cases, add page fault handling

V. Testing:  
+ NOTE: Make sure a file named 'swapfile' exists in the code directory

+ helloworld: 
	- helper user program that prints "Hello World".
+ matmult2: 
	- helper user program that is a copy of matmult, but prints the output to console.


VI. Discussion:
	+ Experiment expectation.  (What is supposed to happen.)
		passport_office: Runs a full simulation of 10 customers going through the passport office
		run_passport_office: Executes two full simulations of two different passport offices going through their customers
		testexec: "Hello World" is printed 5 times to the console.
		testfork: "Hello World" is printed 5 times to the console.
		testforkexec1:  Output is "Hello world" 4 times and the results of matmult twice.
		testforkexec2: 	Output is the result of matmult2 once, and "Hello world" 7 times total.
		testforkexecbad: Prints errors, otherwise executes.
		testlock - testing lock functionality by successfully creating/acquiring/releasing a lock.
		testlockbad - testing bad calls to lock syscalls, such as incorrect indices. The program does not break but prints warnings and runs to completion.
		testcondition1 - calls acquire, broadcast, and release in the correct order and runs to completion
		testcondition2 - calls acquire, signal, and release in the correct order and runs to completion
		testconditionbad1 - prints error statement for trying to use condition with invalid lock
		testconditionbad2 - prints error statement for trying to call broadcase without acquiring the lock
		testprint - print 5.
		testrand - prints random number.
	+ Experiment result.  (What actually happened.)
		pasport_office: Successfully runs full simulation of 10 customers going through passport office
		run_pasport_office: Successfully runs two full simulations of customers going through the passport office
		testexec: "Hello World" is printed 5 times to the console.
		testfork: "Hello World" is printed 5 times to the console.
		testforkexec1:  Output is "Hello world" 4 times and the results of matmult twice.
		testforkexec2: 	Output is the result of matmult2 once, and "Hello world" 7 times total.
		testforkexecbad: Prints errors, otherwise executs.
		testlock - testing lock functionality by successfully creating/acquiring/releasing a lock.
		testlockbad - testing bad calls to lock syscalls, such as incorrect indices. The program does not break but prints warnings and runs to completion.
		testcondition1 - calls acquire, broadcast, and release in the correct order and runs to completion
		testcondition2 - calls acquire, signal, and release in the correct order and runs to completion
		testconditionbad1 - prints error statement for trying to use condition with invalid lock
		testconditionbad2 - prints error statement for trying to call broadcast without acquiring the lock
		testprint - print 5.
		testrand - prints random number.
	+ Explanation
		testexec: Because the helloworld program is being launched using the Exec syscall, we know that Exec correctly creates a new process. Using Exec multiple times shows that our program is correctly handling the allocation of memory.
		testfork: Because we are creating additional threads with the Fork syscall, we know that we are successfully adding threads to the process that are launching and completing. Using Fork multiple times shows that our program is correctly handling allocation of memory within a singular process.
		testforkexec1: This program proves that we support not only multiple single-threaded programs and multithreaded uniprograms, but multithreaded multiprogram execution. Because the print statements execute correctly, we know that we can handle both multiple programs and multiple threads.
		testforkexec2: This programs proves that we can fork from within a program created using Exec. This shows that we can not only use fork from our original process but from new created processes, further proving our memory allocation robustness and correctness.
		testforkexecbad: Because the user program could send any data to the OS for the system call, this proves the OS will not be compromised by bad input.
		testlock - Works because it correctly follows the order of creating, acquiring, then releasing the lock. This proves the intended functionality of our Lock still works evn with the new syscall wrapper.
		testlockbad - Because a User can call the syscall with any input, this test ensures that the OS does not break with the user program gives invalid input.
		testcondition1 - Works because it correctly uses a singular lock and condition and calls broadcast, proving the functionality of conditions works.
		testcondition2 - Works because it correctly uses a singular lock and condition and calls signal, proving the functionality of conditions works.
		testconditionbad1 - Because a user program could botch the creation of a Condition, ensures that the OS is not affected by such an occasion.
		testconditionbad2 - You must have acquired the Lock to interact with a condition. This ensures that the conditions of Condition are met before Condition functionality can be used.
		testprint - Very simple utility syscall, so unsurpisingly works as intended.
		testrand - Very simple utility syscall, so unsurpisingly works as intended.


VIII. Miscellaneous:
